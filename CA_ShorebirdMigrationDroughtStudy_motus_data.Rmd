---
title: "CSMDS_motus_data"
output: html_document
---

# California Shorebird Migration and Drought Study

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Rmotus package install

```{r}
install.packages("motus", 
                 repos = c(birdscanada = 'https://birdscanada.r-universe.dev',
                           CRAN = 'https://cloud.r-project.org'))

# If individual package fail
install.packages("crayon")
install.packages("assertthat")
install.packages("cpp11")
install.packages("jsonlite")

# If this still fails you can do this and rerun
options(timeout = max(1000, getOption("timeout")))

```

## MotusRBook

Based on examples in **Motus R Book**
by Tara L. Crewe, Zoe Crysler, and Philip Taylor
https://beta.motus.org/MotusRBook/


```{r setup}
library(motus)
library(lubridate)
library(dplyr)
Sys.setenv(TZ = "UTC")

# California-Shorebird Migration and Drought Study
# Stopped using this to make things more clear and eliminate mismatches
# proj.num = 458 

# Cosumnes River Preserve, Merced NWR, Staten Island,
# Colusa NWR, Sacramento NWR, Montna Farms,
# Conaway Ranch, Napa Sonoma Marsh, Bird Haven, 
# Pixley NWR, Kern NWR, Dangermond Preserve

df.458.serno = c("CTT-D00F694B4918", "CTT-ECDC2345F5CC", "CTT-BF45E4FCD972", 
             "CTT-9697596E76D6", "CTT-1EC0EE6D76E6", "CTT-2CFE3C766E92", 
             "CTT-B376A7ED47F6", "CTT-21FFFAC8B255", "CTT-F51A7C862D57", 
             "CTT-140682CCEB52", "CTT-8F11AA6622E1", "CTT-515928C2BC39")


# Project
## First time
## Will need Motus login

proj.458.sql.motus <- tagme(projRecv = 458, new = TRUE, update = TRUE)

# Receivers


motusLogout()
```

## Update files

You can update individual sql files or all at once.

```{r update}
# Project
## Update existing project from motus database
proj.458.sql.motus <- tagme(projRecv = 458, new = FALSE, update = TRUE)

# California-Shorebird Migration and Drought Study
rec.458.names = paste0(c("cosumnes", "merced", "staten",
                     "colusa", "sacramento", "montna",
                     "conaway","napasonoma", "birdhaven",  
                     "pixley", "kern", "dangermond"), ".sql.motus")

# Individually
# Depricated for codewith station name below
# rec.458.names[1] <- tagme(projRecv = df.458.serno[1], new = TRUE, update = TRUE)
# rec.458.names[2] <- tagme(projRecv = df.458.serno[2], new = TRUE, update = TRUE)
# rec.458.names[3] <- tagme(projRecv = df.458.serno[3], new = TRUE, update = TRUE)
# rec.458.names[4] <- tagme(projRecv = df.458.serno[4], new = TRUE, update = TRUE)
# rec.458.names[5] <- tagme(projRecv = df.458.serno[5], new = TRUE, update = TRUE)
# rec.458.names[6] <- tagme(projRecv = df.458.serno[6], new = TRUE, update = TRUE)
# rec.458.names[7] <- tagme(projRecv = df.458.serno[7], new = TRUE, update = TRUE)
# rec.458.names[8] <- tagme(projRecv = df.458.serno[8], new = TRUE, update = TRUE)
# rec.458.names[9] <- tagme(projRecv = df.458.serno[9], new = TRUE, update = TRUE)
# rec.458.names[10] <- tagme(projRecv = df.458.serno[10], new = TRUE, update = TRUE)
# rec.458.names[11] <- tagme(projRecv = df.458.serno[11], new = TRUE, update = TRUE)
# rec.458.names[12] <- tagme(projRecv = df.458.serno[12], new = TRUE, update = TRUE)
# Got 6 TNC stations done on first run

# All at once with variable assignment so it is comparable to the individual way
# TNC
# for (k in 1:length(df.458.serno)) {
#   assign(rec.458.names[k], tagme(df.458.serno[k], update = TRUE))
# }

# All at once without varialbe assignment
# for (k in 1:length(df.serno)) {
#   tagme(df.serno[k], update = TRUE)
# }

# All at once for all of your projects
### Beware this will take a really long time
# tagme()

# This will get data on all projects and receiver deployments
## Access this in recDeps table in proj.projnum.sql.motus
metadata(proj.458.sql.motus, projectIDs = 458)

# Work with one receiver
#  After running tagme for one of the names in the list above
# tagme(projRecv = df.458.serno[8], new = TRUE, update = TRUE)
# Connect to external .motus file without updating
# napa.sonoma.motus = tagme("CTT-21FFFAC8B255", update = F)
napa.sonoma.motus = tagme("CTT-21FFFAC8B255", update = T)
pixley.motus = tagme("CTT-140682CCEB52", update = T)
kern.motus = tagme("CTT-8F11AA6622E1", update = T)
cosumnes.motus = tagme("CTT-D00F694B4918", new=TRUE, update = T)
colusa.motus = tagme("CTT-9697596E76D6",  new=TRUE, update = T)
birdhaven.motus = tagme("CTT-F51A7C862D57",  new=TRUE, update = T)

# Get table and fix datetimes
tbl.napa.sonoma.alltags <- tbl(napa.sonoma.motus, "alltags")
tbl.pixley.alltags <- tbl(pixley.motus, "alltags")
tbl.kern.alltags <- tbl(kern.motus, "alltags")
tbl.cosumnes.alltags <- tbl(cosumnes.motus, "alltags")
tbl.colusa.alltags <- tbl(colusa.motus, "alltags")
tbl.birdhaven.alltags <- tbl(birdhaven.motus, "alltags")

# df.napa.sonoma.alltags <- tbl.napa.sonoma.alltags %>% 
#   collect() %>% 
#   as.data.frame() %>%     # for all fields in the df (data frame)
#   mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))
df.pixley.alltags <- tbl.pixley.alltags %>% 
  collect() %>% 
  as.data.frame() %>%     # for all fields in the df (data frame)
  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))
df.pixley.alltags <- tbl.pixley.alltags %>% 
  collect() %>% 
  as.data.frame() %>%     # for all fields in the df (data frame)
  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))
df.pixley.alltags <- tbl.pixley.alltags %>% 
  collect() %>% 
  as.data.frame() %>%     # for all fields in the df (data frame)
  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))
df.pixley.alltags <- tbl.pixley.alltags %>% 
  collect() %>% 
  as.data.frame() %>%     # for all fields in the df (data frame)
  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))
df.pixley.alltags <- tbl.pixley.alltags %>% 
  collect() %>% 
  as.data.frame() %>%     # for all fields in the df (data frame)
  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))
df.pixley.alltags <- tbl.pixley.alltags %>% 
  collect() %>% 
  as.data.frame() %>%     # for all fields in the df (data frame)
  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))


motusLogout()
```

## Tag detection range testing

For this we need to decide which signal strengths to associate with which coordinates.
For now we use nearest point in time.
Uses code example here:
https://stackoverflow.com/questions/70974563/r-merge-two-data-frames-based-on-nearest-date-and-time-match

Note most napa.sonoma detections were on antenna aimed East (95 true, 108 magnetic) since all the land is North and East of the station.

```{r range}
library(rgdal)
library(lubridate)
library(ggplot2)
library(dplyr)

# points.boat = readOGR("TagTesting/LEVI_TAG_CHECK_TRACK.kml", "Points")
# points.kml = readOGR("TagTesting/LEVI LAND CHECK 6-30.kml", "trk")
# points.pixley = readOGR("TagTesting/PixleyTrackCaltopo.kml", "Points")
# The kml does not seem useful, since time domain data is not stored, afaik
## Don't know why this does not work now
# points.sonoma.gpx = readOGR("TagTesting/LEVI LAND CHECK.gpx", "track_points")
points.pixley.gpx = readOGR("TagTesting/PixleyTrackCaltopo.gpx", "track_points")
points.kernNW.gpx = readOGR("TagTesting/Kern NW Test.gpx", "track_points")
points.kernNWR.gpx = readOGR("TagTesting/Kern NWR Test.gpx", "track_points")
points.cosumnes.gpx = readOGR("TagTesting/Cosumnes Track 72722.gpx", "track_points")
points.colusa.gpx = readOGR("TagTesting/Colusa Motus Test 81822.gpx", "track_points")
points.birdhaven.gpx = readOGR("TagTesting/BirdHaven Motus Test 81822.gpx", "track_points")


# Create datetime from end and store in blank timestamp field
## Boat tag did not get picked up
# points.boat@data = points.boat@data %>%
#   mutate(timestamp = as_datetime(end, tz = "UTC"))
# range(points.boat@data$timestamp)

# points.sonoma.gpx@data = points.sonoma.gpx@data %>%
#   mutate(timestamp = as_datetime(end, tz = "UTC"))
# range(points.sonoma.gpx@data$timestamp)

points.pixley.gpx@data = points.pixley.gpx@data %>%
  mutate(timestamp = as_datetime(time, tz = "UTC"))
range(points.pixley.gpx@data$timestamp)

points.kernNW.gpx@data = points.kernNW.gpx@data %>%
  mutate(timestamp = as_datetime(time, tz = "UTC"))
range(points.kernNW.gpx@data$timestamp)

points.kernNWR.gpx@data = points.kernNWR.gpx@data %>%
  mutate(timestamp = as_datetime(time, tz = "UTC"))
range(points.kernNWR.gpx@data$timestamp)

points.cosumnes.gpx@data = points.cosumnes.gpx@data %>%
  mutate(timestamp = as_datetime(time, tz = "UTC"))
range(points.cosumnes.gpx@data$timestamp)

points.colusa.gpx@data = points.colusa.gpx@data %>%
  mutate(timestamp = as_datetime(time, tz = "UTC"))
range(points.colusa.gpx@data$timestamp)

points.birdhaven.gpx@data = points.birdhaven.gpx@data %>%
  mutate(timestamp = as_datetime(time, tz = "UTC"))
range(points.birdhaven.gpx@data$timestamp)


# Filter down to test tag and day(s) of test
df.alltags.149052 = df.napa.sonoma.alltags %>%
  filter(motusTagID == 49052,
         ts > "2022-06-29",
         ts < "2022-07-01")
df.pixley.alltags.56719 = df.pixley.alltags %>%
  filter(motusTagID == 56719,
         ts > "2022-07-12",
         ts < "2022-07-15")
df.pixley.alltags.57234 = df.pixley.alltags %>%
  filter(motusTagID == 57234,
         ts > "2022-07-12",
         ts < "2022-07-15")


# Plot signal strength colored by antenna

## napa.sonoma
p.sig  = df.alltags.149052 %>% 
  ggplot(aes(x = ts, y = sig, col = as.factor(antBearing))) +
  theme_bw() + 
  geom_point() + 
  labs(x = "Time of day", y = "Signal strength") +
  scale_color_discrete(name = "Antenna bearing") +
  facet_grid(recvDeployName ~ .)
p.sig
## Pixley
pixley.56719.sig  = df.pixley.alltags.56719 %>% 
  ggplot(aes(x = ts, y = sig, col = as.factor(antBearing))) +
  theme_bw() + 
  geom_point() + 
  labs(x = "Time of day", y = "Signal strength") +
  scale_color_discrete(name = "Antenna bearing") +
  facet_grid(recvDeployName ~ .)
pixley.56719.sig
pixley.57234.sig  = df.pixley.alltags.57234 %>% 
  ggplot(aes(x = ts, y = sig, col = as.factor(antBearing))) +
  theme_bw() + 
  geom_point() + 
  labs(x = "Time of day", y = "Signal strength") +
  scale_color_discrete(name = "Antenna bearing") +
  facet_grid(recvDeployName ~ .)
pixley.57234.sig
 
# Cosumnes Life Tag 2D342D78, Hybrid Tag 612A072A
# Colusa single Hybrid tag #612A072A
# Birdhaven single Hybrid tag #612A072A



# merge in signal strength from Motus records closest in time
points@data$tmp = round_date(points@data$timestamp, "minute")
df.alltags.149052$tmp = round_date(df.alltags.149052$ts, "minute")

points.pixley.gpx@data$tmp = round_date(points.pixley.gpx@data$timestamp, "minute")
df.pixley.alltags.56719$tmp = round_date(df.pixley.alltags.56719$ts, "minute")
df.pixley.alltags.57234$tmp = round_date(df.pixley.alltags.57234$ts, "minute")

points@data$grp = 1:nrow(points@data)

points.pixley.gpx@data$grp = 1:nrow(points.pixley.gpx@data)

points.merged = merge(points@data, df.alltags.149052, "tmp") 
points.merged.nearest = points.merged %>%
  group_by(grp) %>% 
  slice(which.min(abs(difftime(timestamp, ts)))) %>% 
  ungroup() %>% 
  select(-c(tmp, Name, description, drawOrder, icon, ts, tsCorrected, sigsd,
            noise, freq, freqsd, slop, burstSlop, tagProjID, mfgID, tagType, 
            codeSet, mfg, tagModel, tagLifespan, nomFreq, tagBI, pulseLen,
            tagDeployID, speciesID, markerNumber, markerType , tagDeployStart,
            tagDeployEnd, tagDepLat, tagDepLon, tagDepAlt, tagDepComments,
            tagDeployTest, fullID))
points = merge(points, points.merged.nearest, "grp")
plot(points)

points.pixley.merged = merge(points.pixley.gpx@data, df.pixley.alltags.56719, "tmp") 
points.pixley.merged.nearest = points.pixley.merged %>%
  group_by(grp) %>% 
  slice(which.min(abs(difftime(timestamp, ts)))) %>% 
  ungroup() %>% 
  select(-c(tmp, track_fid, track_seg_id, time, "magvar", "geoidheight", "name", 
            "cmt", "desc", "src", "link1_href", "link1_text", "link1_type", 
            "link2_href", "link2_text", "link2_type", "sym", "type", "fix" , 
            "sat", "hdop", "vdop", "pdop" , "ageofdgpsdata" , "dgpsid", ts, 
            tsCorrected, sigsd, noise, freq, freqsd, slop, burstSlop, tagProjID, 
            mfgID, tagType, codeSet, mfg, tagModel, tagLifespan, nomFreq, tagBI, 
            pulseLen, tagDeployID, speciesID, markerNumber, markerType , 
            tagDeployStart, tagDeployEnd, tagDepLat, tagDepLon, tagDepAlt, 
            tagDepComments, tagDeployTest, fullID))
points.pixley = merge(points.pixley.gpx, points.pixley.merged.nearest, "grp")
plot(points.pixley)

points.pixley.merged = merge(points.pixley.gpx@data, df.pixley.alltags.57234, "tmp") 
points.pixley.merged.nearest = points.pixley.merged %>%
  group_by(grp) %>% 
  slice(which.min(abs(difftime(timestamp, ts)))) %>% 
  ungroup() %>% 
  select(-c(tmp, track_fid, track_seg_id, time, "magvar", "geoidheight", "name", 
            "cmt", "desc", "src", "link1_href", "link1_text", "link1_type", 
            "link2_href", "link2_text", "link2_type", "sym", "type", "fix" , 
            "sat", "hdop", "vdop", "pdop" , "ageofdgpsdata" , "dgpsid", ts, 
            tsCorrected, sigsd, noise, freq, freqsd, slop, burstSlop, tagProjID, 
            mfgID, tagType, codeSet, mfg, tagModel, tagLifespan, nomFreq, tagBI, 
            pulseLen, tagDeployID, speciesID, markerNumber, markerType , 
            tagDeployStart, tagDeployEnd, tagDepLat, tagDepLon, tagDepAlt, 
            tagDepComments, tagDeployTest, fullID))
points.pixley = merge(points.pixley.gpx, points.pixley.merged.nearest, "grp")
plot(points.pixley)

```
## Leaflet map to examine data

```{r maptesttag}
library(leaflet)

pal <- colorNumeric(
  palette = "Reds",
  domain = points$sig)

icons <- awesomeIcons(
  icon = 'color-wand-outline',#'ios-close' 'wifi-sharp'
  iconColor = 'black',
  library = 'ion',
  markerColor = ifelse(is.na(points$sig),"#d9d9d9",pal(points$sig))
)


leaflet(points) %>%
  addTiles() %>%
  addProviderTiles('Esri.WorldImagery') %>%
  # addMarkers()
  # This only produced one color
  # addAwesomeMarkers(icon=icons, label=~as.character(sig))
  addCircleMarkers(color = ifelse(is.na(points$sig),"#737373",pal(points$sig)),
                   radius = ifelse(is.na(points$sig), 2, 10),
                   popup = ~as.character(points$sig), 
                   label = ~as.character(points$sig))

pal <- colorNumeric(
  palette = "Reds",
  domain = points.pixley$sig)

icons <- awesomeIcons(
  icon = 'color-wand-outline',#'ios-close' 'wifi-sharp'
  iconColor = 'black',
  library = 'ion',
  markerColor = ifelse(is.na(points.pixley$sig),"#d9d9d9",pal(points.pixley$sig))
)


leaflet(points.pixley) %>%
  addTiles() %>%
  addProviderTiles('Esri.WorldImagery') %>%
  # addMarkers()
  # This only produced one color
  # addAwesomeMarkers(icon=icons, label=~as.character(sig))
  addCircleMarkers(color = ifelse(is.na(points.pixley$sig),"#737373",pal(points.pixley$sig)),
                   radius = ifelse(is.na(points.pixley$sig), 2, 10),
                   popup = ~as.character(points.pixley$sig), 
                   label = ~as.character(points.pixley$sig))

```


## Accessing tables

Once you have the .motus files downloaded and updated, you can look at them 
using a database viewer like dBeaver by connecting an sQLite connection to the 
location on disk.

```{r data}
library(DBI)
library(RSQLite)

file.name <- dbConnect(SQLite(), "project-458.motus")
dbListTables(file.name)
dbListFields(file.name, "species")

# California-Shorebird Migration and Drought Study
# proj.num = 458
# This just points to the database in the default directory

proj.458.sql.motus = tagme(458, update = FALSE)
# virtual table
tbl.458.alltags <- tbl(proj.458.sql.motus, "alltags")
# Filter the data
# This is a filtered table with over 3 million observations
# Last time I tried this it failed after a long time
tbl.458.DUNL <- tbl(proj.458.sql.motus, "alltags") %>%
  filter(speciesEN == "Dunlin") %>%
  collect()
# Get the daily median location of GPS points for these data
DUNL.GPS <- getGPS(src = proj.458.sql.motus, data = tbl.458.DUNL)

# Get flat table
# df.458.alltags <- tbl.458.alltags %>% 
#   collect() %>% 
#   as.data.frame()

# or
# Get table and fix datetimes
df.458.alltags <- tbl.458.alltags %>% 
  collect() %>% 
  as.data.frame() %>%     # for all fields in the df (data frame)
  mutate(ts = as_datetime(ts, tz = "UTC", origin = "1970-01-01"))

# Remove old variables without project numbers in them below here

# export as RDS to preserve dateTimes
# You can then just import this to work with tag data from before the date of export
#STOPPED HERE 6/28/22
saveRDS(df.458.alltags, "df_alltags_458.06_22.rds")
# To read it back in
# df.alltags.458.06_22 <- readRDS("df_alltags_458.06_22.rds")
```

## Tag Deployments


```{r tagdeploys}
# 1. download full tag metadata for our project only
# See update section above

# 2. determine how many tags are registered to your project
tbl.458.tags <- tbl(proj.458.sql.motus, "tags")
df.458.tags <- tbl.458.tags %>%
  filter(projectID == 458) %>%
  collect() %>%
  as.data.frame()
nrow(df.458.tags)
unique(df.458.tags$tagID)

# 3. determine how many of those registered tags were deployed
tbl.458.tagDeps <- tbl(proj.458.sql.motus, "tagDeps") 

df.458.tagDeps <- tbl.458.tagDeps %>%
  filter(projectID == 458) %>%
  collect() %>%
  as.data.frame() %>% # once in df format, can format dates with lubridate
  mutate(tsStart = as_datetime(tsStart, tz = "UTC", origin = "1970-01-01"),
         tsEnd = as_datetime(tsEnd, tz = "UTC", origin = "1970-01-01")) 
  # find tags that are not deployed
anti_join(df.458.tags, df.458.tagDeps, by = "tagID")
  # - currently there are 20, and some show as deployed, so not sure what this means

  # find multiple deployments
df.alltags.458.01_22 %>%
  select(motusTagID, tagDeployID) %>%
  filter(!(is.na(tagDeployID))) %>% # remove NA tagDeployIDs
  distinct() %>%
  group_by(motusTagID) %>%
  mutate(n = n()) %>%
  filter(n > 1)
  # - Currently there are 22 tags with multiple deployments
df.alltags.458.01_22 <- df.alltags.458.01_22 %>%
  mutate(motusTagDepID = paste(motusTagID, tagDeployID, sep = "."))
df.458.tagDeps <- df.458.tagDeps %>%
  mutate(motusTagDepID = paste(tagID, deployID, sep = "."))


# Plot timelines
# install.packages("vistime")
library(tidyverse)
library(ggplot2)
library(vistime)
df.458.timeline = df.458.tagDeps %>%
  select(fullID, start = tsStart, end = tsEnd) %>%
  mutate(event = str_extract(fullID, "(?<=#).+(?=:)")) %>%
  filter(!is.na(start))

p = gg_vistime(df.458.timeline)
p

# 4. determine location of tag deployments
library(ggplot2)
library(rworldmap)
na.lakes <- map_data(map = "lakes")
na.lakes <- mutate(na.lakes, long = long - 360)

# Include all of the Americas to begin
na.map <- map_data(map = "world2")
na.map <- filter(na.map, region %in% c("Canada", "USA"))
                               
na.map <- mutate(na.map, long = long- 360)

# set limits to map based on locations of detections, ensuring they include the
# deployment locations
#  These can be set arbitrarily using coordinates from Google Earth
xmin <- min(df.458.tagDeps$longitude, na.rm = TRUE) - 5 # -120 #
xmax <- max(df.458.tagDeps$longitude, na.rm = TRUE) + 5 # -116 #
ymin <- min(df.458.tagDeps$latitude, na.rm = TRUE) - 5 # 35 #
ymax <- max(df.458.tagDeps$latitude, na.rm = TRUE) + 5 # 37 #
                
# map using ggplot
ggplot(data = na.lakes, aes(x = long, y = lat)) + 
  geom_polygon(data = na.map, aes(long, lat, group = group), 
               colour = "grey", fill="grey98") + 
  geom_polygon(aes(group = group), colour = "grey", fill = "white") +
  coord_map(projection = "mercator", 
            xlim = c(xmin, xmax), 
            ylim = c(ymin, ymax)) +
  labs(x = "", y = "") + 
  theme_bw() + 
  geom_point(data = filter(df.458.tagDeps, projectID == 458), 
             aes(longitude, latitude), size = 2, shape = 1, colour = "red")
  # - One tag is deployed way out of range

# 5. determine completeness and accuracy of tag deployment metadata
  # Range of metadata values
df.458.tagDeps %>%
  select(tagID, projectID, tsStart, tsEnd, speciesID, latitude, longitude) %>%
  summary()
#  There are 
#    - two missing tsStart and end dates
#    - 12 missing species IDs
#    - 25 missing lat/lons
#    - deployment start dates are 2019-07-17 to 2021-10-13

  # Check that species IDs are appropriate for your data
sp.list <- unique(df.458.tagDeps$speciesID)
tbl.458.species <- tbl(proj.458.sql.motus, "species") 
tbl.458.species %>%
  filter(id %in% sp.list) %>%
  collect() %>%
  as.data.frame()
  # just TRBL and YBCU

```

## Reciever Metadata


```{r recievermeta}
library(tidyverse)
# proj.458.sql.motus <- tagme(458, update = TRUE)

# 1. download full receiver metadata across the network
# This may have just been run in one of the blocks above (around line 116)
metadata(proj.458.sql.motus)

# 2. determine number of project receiver deployments
tbl.458.recvDeps <- tbl(proj.458.sql.motus, "recvDeps")
df.458.projRecvs <- tbl.458.recvDeps %>%
  filter(projectID == 458, status == "active") %>%
  collect() %>%
  as.data.frame() %>%
  mutate(tsStart = as_datetime(tsStart, tz = "UTC", origin = "1970-01-01"),
         tsEnd = as_datetime(tsEnd, tz = "UTC", origin = "1970-01-01"))

summary(df.458.projRecvs)
# - Lat and lon are reasonable
# - tsStart ranges from 2019-03-22 to 2021-07-27

  # - Red Tail Hill is no longer missing
  # - missing elevation
  # - missing utcoffset

df.458.projRecvs %>%
  mutate(dateStart = date(tsStart)) %>% 
  select(-serno,-fixtureType, -macAddress, -tsStart, -tsEnd, -elevation, 
         -projectID, -status, -receiverType, -siteName) %>%
  arrange(deviceID, latitude, dateStart)

# 3. determine timing of project receiver deployments
df.458.projRecvs.long <- df.458.projRecvs %>%
  select(deviceID, deployID, tsStart, tsEnd) %>% 
  gather(when, ts, c(tsStart, tsEnd)) %>%
  # fake end date:
  mutate(ts = if_else(is.na(ts), max(ts, na.rm = TRUE) + duration(1, "month"), ts)) 

ggplot(data = df.458.projRecvs.long, 
       aes(x = ts, y = as.factor(deviceID), colour = as.factor(deployID))) +
  theme(legend.position = "none") +
  geom_line(lwd = 3) + 
  # instead, centre to the right
  geom_text(data = filter(df.458.projRecvs.long, when == "tsStart"), 
            aes(label = deployID), hjust = "left", nudge_y = 0.2, size = 3, angle = 45) +
  theme_bw() +
  labs(x = "Year", y = "Receiver ID")

ggplot(data = df.458.projRecvs.long, 
       aes(x = yday(ts), y = as.factor(deviceID), colour = as.factor(deployID))) +
  theme_bw() +
  theme(legend.position = "none") + 
  geom_line(lwd = 3) + 
  # centre labels to the left
  geom_text(data = filter(df.458.projRecvs.long, when == "tsStart"), 
            aes(label = deployID), hjust = "left", nudge_y = 0.4, size = 3) +
  labs(x = "Day of year", y = "Receiver ID") +
  facet_grid(year(ts) ~ ., scales = "free")

# 4. determine location of network-wide and project receiver deployments
df.458.recvDeps <- tbl.458.recvDeps %>%
  collect() %>%
  as.data.frame() %>%
  mutate(tsStart = as_datetime(tsStart, tz = "UTC", origin = "1970-01-01"),
         tsEnd = as_datetime(tsEnd, tz = "UTC", origin = "1970-01-01"))

na.lakes <- map_data(map = "lakes")
na.lakes <- mutate(na.lakes, long = long - 360)

na.map <- map_data(map = "world2")
na.map <- filter(na.map, 
                 region %in% c("Canada", "USA", "Mexico", "lakes", "Belize", 
                               "Costa Rica", "Panama", "Guatemala", "Honduras", 
                               "Nicaragua", "El Salvador", "Colombia", "Venezuela", 
                               "Ecuador", "Peru", "Brazil", "Guyana","Suriname", 
                               "Bolivia", "French Guiana", "Jamaica", "Cuba", 
                               "Haiti", "Dominican Republic", "The Bahamas", 
                               "Turks and Caicos Islands", "Puerto Rico", 
                               "British Virgin Islands", "Montserrat", "Dominica", 
                               "Saint Lucia", "Barbados", "Grenada", 
                               "Trinidad and Tobago", "Chile", "Argentina", 
                               "Uruguay", "Paraguay")) %>%
  mutate(long = long - 360)

xmin <- min(df.458.recvDeps$longitude, na.rm = TRUE) - 2
xmax <- -20 # restrict to the Americas (excluding a few points in Europe)
ymin <- -60 #min(df.458.recvDeps$longitude, na.rm = TRUE) - 2
ymax <- max(df.458.recvDeps$latitude, na.rm = TRUE) + 2

ggplot(data = na.lakes, aes(x = long, y = lat)) + 
  theme_bw() + 
  geom_polygon(data = na.map, aes(long, lat, group = group), 
               colour = "grey", fill = "grey98") +
  geom_polygon(aes(group = group), colour = "grey", fill = "white") +
  coord_map(projection = "mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax)) +
  labs(x = "", y = "") + 
  geom_point(data = df.458.recvDeps, 
             aes(longitude, latitude, colour = as.logical(projectID == 458)), 
             size = 1, shape = 4) +
  scale_colour_manual(values = c("grey30", "red"), name = "Project 458 Deployment") 

xmin <- min(df.458.projRecvs$longitude, na.rm = TRUE) - 2
xmax <- max(df.458.projRecvs$longitude, na.rm = TRUE) + 2
ymin <- min(df.458.projRecvs$latitude, na.rm = TRUE) - 1
ymax <- max(df.458.projRecvs$latitude, na.rm = TRUE) + 1
                
# map
ggplot(data = na.lakes, aes(x = long, y = lat))+ 
  theme_bw() + 
  geom_polygon(data = na.map, aes(long, lat, group = group), 
               colour = "grey", fill = "grey98") +
  geom_polygon(aes(group = group), colour = "grey", fill = "white") +
  coord_map(projection = "mercator", xlim = c(xmin, xmax), ylim = c(ymin, ymax)) +
  labs(x = "", y = "") +
  geom_point(data = filter(df.458.projRecvs, 
                           year(tsStart) %in% 2020:2021, 
                           !is.na(latitude)),  # remove mobile receivers
             aes(longitude, latitude, colour = as.factor(deviceID)), size = 2, shape = 1)+
  scale_colour_discrete(name = "Receiver ID") 


# 5. determine completeness and accuracy of receiver metadata

tbl.458.antDeps <- tbl(proj.458.sql.motus, "antDeps") 

df.458.antDeps <- tbl.458.antDeps %>%
  select(deployID, port, antennaType, bearing, heightMeters) %>%
  collect() %>%
  as.data.frame()

# receiver deployments; select variables of interest
df.458.ant.recvDeps <- df.458.recvDeps %>%
  select(deployID, receiverType, deviceID, name, latitude, longitude, 
         isMobile, tsStart, tsEnd, projectID, elevation) 

df.stationDeps <- left_join(df.458.ant.recvDeps, df.458.antDeps, by = "deployID")

# Filter to just our project if needed
df.458.stationDeps <- filter(df.stationDeps, projectID == 458)

summary(df.stationDeps)
summary(df.458.stationDeps)
# Our station deployments seem reasonable
# Current deployments
#  Red Tail Hill 2020-10-02
#  Long Canyon   2020-10-21
#  Canebrake     2021-07-27

```


## Data cleaning

```{r cleaning}
Sys.setenv(tz = "UTC")

library(motus)
library(tidyverse)
library(lubridate)

# Kern River Valley Tri-colored Blackbird Study
# proj.num = 458 

# proj.458.sql.motus <- tagme(458, update = F)

# tbl(proj.458.sql.motus, "alltags") %>% # This brings data in from local database
df.alltags.458.01_22 %>% # This uses the local copy created above
  filter(tagProjID == 458) %>% # subset to include only tags registered to project
  count(motusTagDepID) %>%
  as.data.frame()

# tbl(proj.458.sql.motus, "alltags") %>% # This brings data in from local database
df.alltags.458.01_22 %>% # This uses the local copy created above
  filter(tagProjID == 458) %>% # subset to include only tags registered to project
  mutate(rl.gt.3 = if_else(runLen == 3, "run 3", "run > 3")) %>%
  count(motusTagDepID, rl.gt.3) %>%
  collect() %>%
  spread(key = rl.gt.3, value = n)
# - large numbers have NA for deployment ID
# - some of these have very large numbers of short runs

filter(tbl(proj.458.sql.motus, "alltags"), runLen <= 3) %>% 
  collect() %>% 
  nrow()
# - over 303,000 short runs

to_remove <- tbl(proj.458.sql.motus, "runs") %>%
  select(runID, motusFilter) %>%
  filter(motusFilter == 0)
tbl_filtered <- anti_join(tbl(proj.458.sql.motus, "alltags"), to_remove, by = "runID")

filter(tbl_filtered, runLen <= 3) %>% 
  collect() %>% 
  nrow()
# 9197 rows have runLen <=3

tbl.458.filtered.alltags <- filterByActivity(proj.458.sql.motus, return = "all")

# Filter out the 9197 rows of short run records

# getGPS expects ts to not be transformed, I think, so commenting out last part
df.458.alltags.sub <- tbl.458.filtered.alltags %>% 
  filter(probability == 1) %>%
  collect() %>%
  as.data.frame() #%>%
  # mutate(ts = as_datetime(ts),  # work with dates AFTER transforming to flat file
  #        tagDeployStart = as_datetime(tagDeployStart),
  #        tagDeployEnd = as_datetime(tagDeployEnd))

df.458.block.0 <- filter(tbl.458.filtered.alltags, probability == 0) %>%
  select(motusTagID, runID) %>%
  distinct() %>%
  collect() %>%
  data.frame()

# Get GPS data
# Retrieve GPS data for each hitID
# This failed with an error
#  When you use `by = 'closest'`
# Error: Problem with `mutate()` column `gpsID`.
# i `gpsID = purrr::map_int(...)`.
# x can only subtract from "POSIXt" objects
# Run `rlang::last_error()` to see where the error occurred.
#  when you use `by = 'daily'`, which I think I used before
# Error: Problem with `mutate()` column `timeBin`.
# i `timeBin = as.integer(.data$ts/by)`.
# x '/' not defined for "POSIXt" objects
# Run `rlang::last_error()` to see where the error occurred.
# This error is due to not running the step above that transforms ts into dateTime

# Use only one of the options below, in order of likely speed
gps_index.458 <- getGPS(proj.458.sql.motus, data = df.458.alltags.sub, by = "daily")
gps_index.458 <- getGPS(proj.458.sql.motus, data = df.458.alltags.sub, by = "closest", cutoff = 20)
gps_index.458 <- getGPS(proj.458.sql.motus, data = df.458.alltags.sub, by = 15)


# Merge GPS points in with our data
df.alltags.458.sub <- left_join(df.458.alltags.sub, gps_index.458, by = "hitID")

filter(df.alltags.458.sub, is.na(gpsLat)) %>% 
  collect() %>% 
  nrow()
filter(df.alltags.458.sub, is.na(gpsLat) & is.na(recvDeployLat)) %>% 
  collect() %>% 
  nrow()
filter(df.alltags.458.sub, is.na(0)) %>% 
  collect() %>% 
  nrow()
filter(df.alltags.458.sub, is.na(999)) %>% 
  collect() %>% 
  nrow()

df.alltags.458.sub.2 <- df.alltags.458.sub %>% 
  mutate(recvLat = if_else((is.na(gpsLat)|gpsLat == 0|gpsLat == 999), 
                           recvDeployLat, gpsLat),
         recvLon = if_else((is.na(gpsLon)|gpsLon == 0|gpsLon == 999), 
                           recvDeployLon, gpsLon),
         recvAlt = if_else(is.na(gpsAlt), recvDeployAlt, gpsAlt)) %>%
  select(-noise, -slop, -burstSlop, -done, -bootnum, -mfgID, 
         -codeSet, -mfg, -nomFreq, -markerNumber, -markerType, 
         -tagDepComments, -fullID, -deviceID, -recvDeployLat, 
         -recvDeployLon, -recvDeployAlt, -speciesGroup, -gpsLat, 
         -gpsLon, -recvAlt, -recvSiteName) %>%
  mutate(recvLat = plyr::round_any(recvLat, 0.05), 
         recvLon = plyr::round_any(recvLon, 0.05),
         recvDeployName = if_else(is.na(recvDeployName), 
                                  paste(recvLat, recvLon, sep=":"), 
                                  recvDeployName))

df.alltags.458.sub.2 %>%
  filter(is.na(recvLat)) %>%
  select(recvLat, recvLon, recvDeployName, recvDeployID, recv, 
         recvProjID, recvProjName) %>%
  distinct()
# None missing on 2022-01-19

fun.getpath <- function(df, pr.nm = 458) {
  df %>%
    filter(tagProjID == pr.nm, # keep only tags registered to the sample project
           !is.na(recvLat) | !(recvLat == 0)) %>% # drops data without lon/lat
    group_by(motusTagID, runID, recvDeployName, ambigID, 
             tagDepLon, tagDepLat, recvLat, recvLon) %>%
    #summarizing by runID to get max run length and mean time stamp:
    summarize(max.runLen = max(runLen), ts.h = mean(lubridate::as_datetime(ts))) %>% 
    arrange(motusTagID, ts.h)
} # end of function

df.alltags.458.path <- fun.getpath(df.alltags.458.sub.2)

df.alltags.458.path %>%
  select(tagDepLon, tagDepLat, recvLat, recvLon, max.runLen, ts.h) %>%
  summary()


tags_all = unique(df.alltags.458.path$motusTagID)
length(unique(df.alltags.458.path$motusTagID))/6

tagset1 = tags_all[1:6]
tagset2 = tags_all[7:12]
tagset3 = tags_all[13:18]
tagset4 = tags_all[19:24]
tagset5 = tags_all[25:30]
tagset6 = tags_all[31:36]
tagset7 = tags_all[37:42]
tagset8 = tags_all[43:48]
tagset9 = tags_all[49:54]
tagset10 = tags_all[55:60]
tagset11 = tags_all[61:66]
tagset12 = tags_all[67:72]
tagset13 = tags_all[73:75]

fun.plot_path = function(path, tagset) {
  ggplot(data = filter(path, 
                     motusTagID %in% tagset), 
       aes(x = ts.h, y = recvLat)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) + 
  geom_point() + 
  geom_path() +
  facet_wrap(~ motusTagID, scales = "free", ncol = 2)
}

fun.plot_path(df.alltags.458.path, tagset1)
fun.plot_path(df.alltags.458.path, tagset2)
fun.plot_path(df.alltags.458.path, tagset3)
fun.plot_path(df.alltags.458.path, tagset4)
fun.plot_path(df.alltags.458.path, tagset5)
fun.plot_path(df.alltags.458.path, tagset6)
fun.plot_path(df.alltags.458.path, tagset7)
fun.plot_path(df.alltags.458.path, tagset8)
fun.plot_path(df.alltags.458.path, tagset9)
fun.plot_path(df.alltags.458.path, tagset10)
fun.plot_path(df.alltags.458.path, tagset11)
fun.plot_path(df.alltags.458.path, tagset12)
fun.plot_path(df.alltags.458.path, tagset13)



```

